Работа в защищённом режиме (32 бита)
####################################

*Согласно документации* AMD_, процессор с архитектурой AMD64 имеет следующие
режимы работы:

.. _AMD: https://www.amd.com/system/files/TechDocs/24593.pdf

- унаследованный реальный режим (legacy real mode),
- унаследованный защищённый режим (legacy protected mode),
- унаследованный режим виртуализации 8086 (legacy Virtual-8086 mode),
- длинный режим совместимости (long compatibility mode).
- длинный 64-битный режим (long 64-bit mode).

*Слова "Унаследованный" (legacy) и "длинный" (long) обычно отбрасываются,
когда речь идёт об особенностях, уникальных для конкретного режима, а
когда речь идёт об общих особенностях, используются только эти слова.*

После сброса процессор переходит в реальный режим.
Переход в другие режимы ПО должно выполнить самостоятельно.

*Режимы существенно отличаются, но первое (в порядке перехода из
реального режима) отличие заключается в сегментации памяти и доступности
регистров.*

Сегментация памяти
==================

Сегментация памяти *есть ничто иное как* разбиение виртуальной памяти на
отрезки (сегменты, segments).
*Когда страничная трансляция и SVM не задействованы, виртуальная память
совпадает с физической.*

Виртуальный адрес вычисляется с использованием эффективного адреса
(effective address,
вычисляемый исходя из значения регистра и кодировки инструкции) и
одного из переключателей (выборщиков) сегмента (segment selectors, особые
регистры процессора), выбираемого в зависимости от ситуации (выборка
инструкции, доступ к данным и т.д.)
Способ вычисления зависит от режима.

Сегментные регистры
~~~~~~~~~~~~~~~~~~~

- Пользовательские (переключатели сегментов)...
    - Код: ``CS``.
    - Данные: ``SS`` (стэк), ``DS`` (по умолчанию для большинства
      обращений к данным), ``ES`` (строковые инструкции), ``FS``, ``GS``.

- Системные...
    - Указатели таблиц: ``GDTR``, ``LDTR``, ``IDTR``.
    - Указатель задачи ``TR`` (Task Register).

Записать данные в переключатель можно со стека (``POP``) или
инструкцией ``MOV``.

Регистр задачи и сегмент состояния задачи
-----------------------------------------

``TR`` используется для выбора сегмента состояния задачи (TSS, Task-State
Segment).
*В данном примере аппаратная поддержка задач не рассматривается.*

Реальный режим
~~~~~~~~~~~~~~

*В этом режиме виртуальных адресов нет: механизм сегментации сразу вычисляет
физический адрес.*
Вычисления выполняются над 16 битными величинами::

    base_address = (S << 4);
    physical_address = base_address + effective_address;

Здесь ``S`` — число в соответствующем переключателе.

*Очевидно, что* доступен только начальный 1 MiB физической памяти.

Защищённый режим
~~~~~~~~~~~~~~~~

Защищённый режим включается битом ``CR0.PE`` (Protection Enabled, разрешение
защиты, бит 0).
Механизм сегментации влияет не только на преобразование адресов, но также
позволяет контролировать выполнение кода.
Настройки задаются через таблицы описателей сегментов:

- global-descriptor table (GDT) — глобальная таблица описателей;
- local-descriptor tables (LDT) — локальная таблица описателей;
- interrupt-descriptor table (IDT) — таблица описателей прерываний.

Размер описателя: 8 байт.
В длинных режимах могут присутствовать **и** описатели по 16 байт.
Выбор из GDT/LDT происходит по переключателю, а из IDT — по номеру вектора
прерывания.
Адрес нулевого описателя и размер таблицы определяется регистрами ``GDTR``,
``LDTR``, ``IDTR``, соответственно.
Значение регистра ``GDTR`` загружается из памяти (с помощью инструкции
``LGDT addr``), где имеет следующий формат...

*Напомним про порядок байт little-endian.*

- байты [1:0]: ограничитель (limit, задаёт размер).
  Ни один байт последнего описателя не может иметь смещение *(от начала
  таблицы)* больше чем ограничитель.
- [10:2]: **виртуальный** (до трансляции по таблицам страниц) адрес нулевого
  описателя; в унаследованных режимах используются только первые 4 байта.
  *TODO: Проверить, что адрес в* ``*DTR`` *виртуальный.*

Формат ``IDTR`` в памяти такой же (и зависит от режима).
Загружается инструкцией ``LIDT addr``.

Загрузка ``LDTR`` выполняется инструкцией ``LLDT selector`` из GDT.
Если ``selector`` нулевой, то ``LDTR`` помечается как неверный, а попытки
использовать LDT вызывают ``#GP`` (кроме инструкций ``LAR``, ``VERR``,
``VERW`` и ``LSL``).

*Документация от* AMD_ *также содержит описание форматов*
``GDTR`` *,* ``LDTR`` *,* ``IDTR`` *непосредственно в процессоре.*
*При этом выделяется программно-видимая (software visible) и скрытая
(hidden) части.*
*Однако, не совсем понятно, как эту информацию можно использовать...*

Уровни привилегий
-----------------

Существует четыре уровня привилегий от 0 *(считается самым привилегированным;
во всяком случае, код современных ОС работает с таким уровнем)* до 3
*(с таким уровнем в современных ОС работают прикладные программы)*.

Формат переключателя сегмента
-----------------------------

Размер: 16 бит.

- [2]: ``TI``, Table Indicator, выбор таблицы (0: GDT, 1:LDT).

- [15:3]: ``SI``, Selector Index, индекс описателя в таблице.
  Размер описателя — 8 байт.
  Если обнулить остальные биты, то получится смещение в таблице.
  Это справедливо и для длинного режима, где есть описатели длиной
  16 байт (повадание в правильное место — это проблема ПО).

- [1:0]:
    - ``CPL``, Current Privilege Level (текущий уровень привилегий),
      когда это **уже** значение ``CS``.

    - ``RPL``, Requestor Privilege Level (запрашиваемый уровень
      привилегий), когда выполняется проверка привилегий
      **в течение присваивания** значения *(любому переключателю)*.

Нулевой переключатель (null selector)
.....................................

Нулевой переключатель (``SI == 0``, ``TI == 0``) в ``DS``, ``ES``, ``FS`` и
``GS`` приводит к ``#GP``, при попытке обращения к данным.
Попытка записать его в ``CS`` сразу вызывает ``#GP``, как и при записи в
``SS`` (кроме 64-битного режима при ``CPL`` < 3).

*См. описание* ``CPUID Fn8000_0021_EAX[NullSelectorClearsBase]`` *(бит 6).*

Преобразование адреса
---------------------

Адрес вычисляется следующим образом::

    virtual address = effective address + base address

Начальный адрес (``base address``) берётся из описателя сегмента,
выбираемого согласно соответствующему переключателю.

Вычисления выполняются над 32-битными величинами, что даёт доступ к начальным
4GiB виртуальной *(и физической? см. возможности трансляции страниц)* памяти.

Формат описателей сегмента
--------------------------

Формат описателя в памяти зависит от того, что он описывает.
Ниже приводится таблица форматов описателей для защищённого режима.
*Описатели в длинных режимах здесь не рассматриваются.*
Столбцы — типы описателей, строки — смещения он начала.
Объединённые столбцы — совпадение назначения битов разных форматов.
Объединённые строки — более длинные поля одного формата.
Некоторые поля раскиданы по не соседствующим битам: см. номера битов поля
в ``[]``.
Начиная со второго двойного слова, второй строкой указаны смещения от начала
второго слова.
Значения битов, определяющие формат *(тип описателя)*, **выделены**.

+-------+-----------------------------------------------------------------------------------+
| Биты  | Описатель сегмента                                                                |
|       +---------------------------+-------------------------------------------------------+
|       | Пользовательский          | Системный                                             |
|       +--------------+------------+-----+------+-----------+-----------+-------+----------+
|       | Код          | Данные     | LDT | TSS  | Call-Gate | Interrupt | Trap  | Task     |
|       |              |            |     |      |           | -Gate     | -Gate | -Gate    |
+=======+==============+============+=====+======+===========+===========+=======+==========+
| 15:0  | Limit [15:0]                           | Target Code Segment           | Reserved |
|       |                                        | Offset [15:0]                 |          |
+-------+----------------------------------------+-------------------------------+----------+
| 31:16 | Base Address [23:0]                    | Target Code Segment Selector  | TSS      |
|       |                                        | [15:0]                        | Selector |
+-------+                                        +-----------+-------------------+----------+
| 36:32 |                                        | Parameter | Reserved                     |
|       |                                        | Count     |                              |
| 4:0   |                                        |           |                              |
+-------+                                        +-----------+------------------------------+
| 39:37 |                                        | Reserved                                 |
|       |                                        |                                          |
| 7:5   |                                        |                                          |
+-------+---------------------------+------------+------------------------------------------+
|       |                           | Type [3:0]                                            |
+-------+---------------------------+-----+------+-----------+-----------+-------+----------+
| 40    | A                         |**0**| **1**| **0**     | **0**     | **1** | **1**    |
|       | (Accessed)                |     |      |           |           |       |          |
| 8     |                           |     |      |           |           |       |          |
+-------+--------------+------------+-----+------+-----------+-----------+-------+----------+
| 41    | R            | W          |**1**| Busy | **0**     | **1**     | **1** | **0**    |
|       | (Readable)   | (Writable) |     |      |           |           |       |          |
| 9     |              |            |     |      |           |           |       |          |
+-------+--------------+------------+-----+------+-----------+-----------+-------+----------+
| 42    | C            | E          |**0**| **0**| **1**     | **1**     | **1** | **1**    |
|       | (Conforming) | (Expand-   |     |      |           |           |       |          |
| 10    |              | Down)      |     |      |           |           |       |          |
+-------+--------------+------------+-----+------+-----------+-----------+-------+----------+
| 43    | **1=Code**   | **0=Data** |**0**| 0. 16-bit                            | **0**    |
|       |              |            |     | 1. 32-bit                            |          |
| 11    |              |            |     |                                      |          |
+-------+--------------+------------+-----+--------------------------------------+----------+
| 44    | S                         | S                                                     |
|       | (System)                  | (System)                                              |
| 12    | **1 = Пользовательский**  | **0 = Системный**                                     |
+-------+---------------------------+-------------------------------------------------------+
| 46:45 | DPL                                                                               |
|       | (Descriptor Privilege Level)                                                      |
| 14:13 |                                                                                   |
+-------+-----------------------------------------------------------------------------------+
| 47    | P                                                                                 |
|       | (Present)                                                                         |
| 15    |                                                                                   |
+-------+----------------------------------------+-------------------------------+----------+
| 51:48 | Limit [19:16]                          | Target Code Segement          | Reserved |
|       |                                        | Offset [31:16]                |          |
| 19:16 |                                        |                               |          |
+-------+----------------------------------------+                               |          |
| 52    | AVL                                    |                               |          |
|       | (Available to software)                |                               |          |
| 20    |                                        |                               |          |
+-------+----------------------------------------+                               |          |
| 53    | Reserved                               |                               |          |
|       |                                        |                               |          |
| 21    |                                        |                               |          |
+-------+----------------------------------------+                               |          |
| 54    | D (Default Operand Size)               |                               |          |
|       |                                        |                               |          |
|       | 0. 16 бит                              |                               |          |
| 22    | 1. 32 бит                              |                               |          |
+-------+----------------------------------------+                               |          |
| 55    | G                                      |                               |          |
|       | (Granularity)                          |                               |          |
| 23    |                                        |                               |          |
+-------+----------------------------------------+                               |          |
| 63:56 | Base Address [31:24]                   |                               |          |
|       |                                        |                               |          |
| 31:24 |                                        |                               |          |
+-------+----------------------------------------+-------------------------------+----------+

Описание полей...

AVL
  ПО может использовать этот бит по своему усмотрению.

A
  ЦП устанавливает этот бит, когда загружает описатель.
  Сброс бита — прерогатива ПО.

P
  Если этот бит сброшен, то при попытке обратиться к сегменту будет ``#NP``.
  *Это может использоваться для реализации механизма вытеснения памяти
  на ПЗУ (т.н. "swap").*

W
  Если сброшен, то разрешено только чтение *(из сегмента)*.
  Выполнять сегмент данных нельзя.
  *TODO: какое исключение?*
  Для стэка ``W`` должен быть установлен.
  *TODO: какое исключение?*

R
  Сброс бита разрешает только выполнение *(кода из сегмента)*.
  Писать в сегмент кода нельзя.
  *TODO: какое исключение?*

  *Понятно, что это сработает, если выбрать описатель сегмента кода
  переключателем для данных.*
  *Но что если выбрать в переключатель данных описатель сегмента данных,
  ссылающийся на те же адреса, что и текущий сегмент кода в выбранный
  переключателем кода?*

D
  Размер операнда/адреса по умолчанию (переопределяется
  префиксами *(инструкций)*).
  Для сегмента стека влияет на используемый размер указателя
  стека (``SP``/``ESP``).

Type
  Биты [43:40] *([11:8])* системных (``S==0``) описателей определяют тип
  описателя.
  В таблице приведены значения битов для каждого типа описателя.
  Не указанные комбинации не корректны.

*Механизмы задач и врат здесь не рассматриваются, но описания полей приведём
на будущее.*

Target Code Segment ``Selector:Offset``
  Загружается в ``CS:EIP`` при передаче управления через
  врата *(выбирая новый сегмент кода и следующую выполняемую инструкцию)*.

TSS Selector
  Выбирает описатель задачи *(см. столбец TSS)* при переходе через врата.

Parameter Count
  Количество параметров, копируемых с текущего стека на новый стек при
  *(автоматическом)* переключении задачи при передаче управления в более
  привилегированное кольцо через врата.
  Размер одного параметра определяется битом 43 *(11)*.

DPL
  Уровень привилегий описателя.

C
  Если 1, то сегмент *(кода)* считается согласованным, иначе
  — несогласованным (nonconforming).
  *Искать понимания в названии бессмысленно, см. контроль привилегий ниже.*

Ограничение размера сегмента
----------------------------

Ограничение размера сегмента выражается в генерации исключения в случае
обращения хотя бы к одному байту, имеющему запрещённый эффективный адрес.
*В данном месте документации он называется смещением (offset).*

Разрешенные адреса определяются полями ``limit``, ``G``, ``D`` и ``E``,
согласно таблице.

+---+---+---------------------------------------------------------------------+
|       | G (масштаб limit)                                                   |
+---+---+--------------------------+------------------------------------------+
| D | E | 0                        | 1                                        |
+---+---+--------------------------+------------------------------------------+
| X | 0 | 0 .\. limit              | 0 .\. (limit << 12) + 0xFFF              |
+---+---+--------------------------+------------------------------------------+
| 0 | 1 | limit + 1 .\. 0xFFFF     | (limit << 12) + 0xFFF + 1 .\. 0xFFFF     |
+---+---+--------------------------+------------------------------------------+
| 1 | 1 | limit + 1 .\. 0xFFFFFFFF | (limit << 12) + 0xFFF + 1 .\. 0xFFFFFFFF |
+---+---+--------------------------+------------------------------------------+

*Проще говоря, Expand-Down (E==1) сегмент простирается в другую сторону от
limit.*
*В документации рекомендуют использовать такой сегмент для стека.*

*TODO: Некоторые ячейки таблицы вызывают желание проверить как это работает
на настоящем процессоре (когда* ``D != G`` *).*

Ограничение доступа к данным
----------------------------

Запрещён доступ к данным с численно меньшим ``DLP``
*(более привилегированным)*::

    if max(CS.CPL, RPL) <= DPL
        разрешить доступ
    else
        #GP

Проверка выполняется при попытке загрузить значение в переключатель
*(не при каждом обращении к данным)*.
Как и загрузка описателя *(из таблицы)*.
Текущий описатель хранится в *(программно)* невидимой части состояния
процессора.
Для загрузки в ``SS`` *(стэк)* требуется равенство всех *(трёх)* уровней.

Контроль привилегий при непосредственной передаче управления
------------------------------------------------------------

Непосредственной передачей управления (direct control transfer),
*согласно* AMD_, называется использование инструкций
``CALL/JMP`` ``[seg]:[offset]`` (т.н. "дальних" (far) версий этих
инструкций).

Непосредственная передача не может изменить ``CPL`` (``RPL`` перетирается).

1. Нельзя передавать управление в подтверждённый сегмент с численно большим
   ``DPL`` (``RPL`` игнорируется)::

    if C and (CPL < DPL):
        #GP

2. Нельзя передавать управление в **не**подтверждённый сегмент с другим
   уровнем привилегий или используя численно больший ``RPL``::

    if (not C) and (CPL != DPL or RPL > CPL):
        #GP

*Других ограничений в документации не обнаружено.*

*Сложно сказать, что имели ввиду разработчики...*
*1-е правило предотвращает случайную передачу управления в код с низкими
привилегиями (хоть он даже и подтверждённый), но не запрещает передать
управление более привилегированному подтверждённому коду.*
*2-е правило позволяет передать управление в неподтверждённый код, но не
позволяет последнему менять уровень привилегий.*
*Также оно не позволяет передать управление в менее привилегированный
неподтверждённый код минуя менее привилегированный подтверждённый.*

Передача управления через врата вызова
--------------------------------------

Передача управления через врата вызова *(Call-Gate)* позволяет поднять
уровень привилегий *(уменьшить CPL)*.
*Этот механизм, как и механизм понижения привилегий через врата задачи
(Task-Gate), тесно связан с механизмом задач и здесь не рассматривается.*
*Код пример работает с наивысшими привилегиями (CPL==0).*

Проверка типа сегмента
----------------------

Процессор автоматически проверяет соответствие типа сегмента *(описателя)*
задаче.
*Напр., CS может ссылаться только на сегмент кода.*
*Ограничения интуитивно понятны; полный список можно найти в разделе 4.13
документации от* AMD_.

*TODO: пример, который попытается нарушить каждое ограничение.*

Пример
======

Целью данного примера является демонстрация максимально простого способа
перевода процессора в защищённый режим
*(в простонародье известный как 32-битный)*.

Основная часть примера сосредоточена в ``main.asm``.
До запуска главной программы происходит типовая загрузка с ПЗУ,
рассмотренная `в соответствующем примере`__.

__ ../01_main/readme.md

Важной особенностью работы в защищённом режиме является возможность
получения машинного кода с помощью компилятора языка Си.
Пример являет собой способ объединения загрузчика, написанного на языке
ассемблера, и целевой программы (``protected.c``), написанной на языке Си.

Основные действия главной программы
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Последним действием главной программы является запуск целевой программы
в защищённом режиме.
*Однако* для этого следует произвести следующие подготовительные действия.

Отключение прерываний
---------------------

Использование прерываний *(и исключений)* в защищённом режиме требует
настроенной таблицы описателей прерываний (IDT), что выходит за рамки
данного упрощённого примера.
*Следовательно,* прерывания должны быть выключены т.к. попытка обработать
прерывание без IDT приведёт к отказу.

Обеспечение работы 21-й адресной линии (A20)
--------------------------------------------

Процессоры 8088 имели 20 линий адреса (A[19:0]).
Данная особенность позволяла за счёт переполнения при вычислении адреса
обращаться к байтам с другого конца адресного пространства, т.к. перенесённая
в 20-й разряд единица, должна была быть выставлена на линию A20, которой
тогда не ещё было.

`Напр.`__, указатель FFFF:0510 арифметически соответствует
адресу 0x100500, но старшую единицу некуда выставить.
Поэтому, физически, он указывал на адрес 0x500.

__ https://wiki.osdev.org/A20_Line

С появлением процессоров, поддерживающих 32 бита адреса, у программ,
использующих такой хак появились проблемы...
Вплоть до того, что производители материнских плат наловчились отключать
по умолчанию 21-ю линию (A20), используя `контроллер клавиатуры`__...

__ https://www.win.tue.nl/~aeb/linux/kbd/A20.html

В те времена, программам использующим 32-битную адресацию приходилось
включать линию A20 явно.
Позже производители начали от такой практики отказываться.
В наше время нельзя гарантировать, в каком состоянии будет находиться
A20 для произвольной вычислительной машины.
В данном примере приводится методы проверки состояния и включения A20.

Перевод процессора в защищённый режим
-------------------------------------

Перед установкой ``CR0.PE`` необходимо загрузить параметры GDT в GDTR
(инструкция ``lgdt``).
Содержимое GDTR (адрес и ограничитель GDT) в данном примере вычисляется
главной программой.
*Хотя, учитывая статичность GDT,* это можно было бы сделать на этапе
компиляции примера.

GDT состоит из трёх описателей:

0. Нулевой описатель ничего не описывает, т.к. нулевой переключатель
   запрещён к использованию в защищённом режиме.

1. Описатель кода задаёт сегмент, покрывающий всё 32-битной пространство
   (``limit == 0xFFFFF``, ``G==1``) памяти, и не выполняющий численное
   изменение адреса при расчётах (``base == 0``).

   Бит ``D==1``, что соответствует 32-х битным адресам и операндам по
   умолчанию
   *(без использования префиксов инструкций, явно задающих размер)*.
   *Очевидно,* что машинный код, который будет выполняться в этом сегменте
   должен быть получен специальным способом.
   *В частности,* для ассемблера используется директива ``.code32``.
   Компиляцию Си с помощью ``gcc`` следует производить с опцией ``-m32``.

   Сегмент кода доступен для чтения (``R == 1``) и помечен как
   "согласованный" (``C == 1``), *но в данном примере это не существенно.*

2. Сегмент данных тоже покрывает всю памяти один к одному.
   Он используется во всех переключателях *(в т.ч. для стека)*.

*Т.о.,* данный пример использует плоскую модель памяти (Flat-Memory Model),
т.е.:

- все сегменты покрывают всё адресное пространство;
- эффективные адреса численно равны виртуальным
  *(а с учётом не включенной страничной трансляции, и физическим)*.

Сразу после установки ``CR0.PE`` выполняется длинный ``jmp``
*на следующую после себя инструкцию,* целью которого является
установка переключателя кода.
Это приведёт к загрузке процессором соответствующего описателя из GDT и
выполнению последующего кода как "32-битного".

Непосредственно перед вызовом целевой программы главная программа
устанавливает все сегменты данных.
Вершина стека (``ESP``) устанавливается на конец 2-ого МиБ.
*Т.о. до кода и данных реального режима остаётся запас в 1 МиБ, что
должно быть достаточно для данного примера.*
*По хорошему, следовало бы разместить стек в отдельном сегменте, настроив
ограничения так, чтобы исключить случайное перетирание стеком других
данных/кода; но данный пример слишком упрощён для этого.*

Целевая программа
~~~~~~~~~~~~~~~~~

Целевая программа в данном примере не несёт особой смысловой нагрузки.
Её задача — вывести на экран сообщение, свидетельствующее об успешной
загрузке.

Много-сегментная модель памяти (Multi-Segmented Model)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*TODO: для другого примера, производного от этого*

Имитация Гарвардской архитектуры
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*TODO: для другого примера, производного от этого*
