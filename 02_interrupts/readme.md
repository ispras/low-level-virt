# Прерывания

Прерывание (_interrupt_) процессора ― это событие при котором
прерывается нормальная последовательность выполнения инструкций,
а текущее состояние сохраняется на
стек.
Затем управление передаётся т.н. _обработчику_ (_handler_).

## Вектор

Прерывания различаются _вектором_ (_vector_).
Вектор прерывания — это индекс в _таблице (описателей) прерываний_
(_interrupt-descriptor table, IDT_).
Выбор вектора зависит от [причины][Vectors] возникновения прерывания.

[Vectors]: https://www.bioscentral.com/misc/interrupts.htm

Таблица прерываний — это массив содержащий информацию об обработчиках
прерываний (формат зависит от режима работы процессора).

## Виды прерываний

Момент прерывания (между какими инструкциями оно
происходит) варьируется в зависимости от причины
Причины прерываний бывают следующие...

- **Исключение** (_Exception_) или **программное прерывание**
  (_Software interrupt_) возникает в следствие выполнения кода и бывает
  следующих видов...

  - Если выполнение инструкции вызывает **сбой** (_Fault_), то вызванные ей
    изменения отменяются.
    Т.е. прерывание _как-бы_ происходит _до_ инструкции, что позволяет
    обработчику внести изменения в состояние системы и возобновить
    работу прерванной программы с той же инструкции, но таким образом, чтобы
    она уже не вызвала сбой.

  - Если выполнение инструкции вызывает **отказ** (_Abort_), то изменения не
    могут быть _надёжно_ отменены автоматически.
    Прерванная программа не подлежит возобновлению.

  - Если выполнение инструкции вызывает **остановку** (_Trap_, англ. ловушка),
    то изменения сохраняются, и прерывание происходит сразу перед следующей
    инструкцией.

- **Внешнее прерывание** (_External interrupt_) возникает по внешней,
  относительно процессора, причине.
  Напр., из-за поступления **запроса прерывания** (_Interrupt request, IRQ_)
  от периферийного устройства.
  Прерывание происходит на границе между инструкциями, когда изменения
  состояния, вызванные последней выполненной инструкцией, применены.

Прерывания, связанные с выполнением инструкций (исключения и
программные прерывания), называют _синхронными_ (англ. synchronous);
внешние прерывания — _асинхронными_ (англ. asynchronous).

<!--
В доках от AMD фигурируют Precise/Imprecise виды прерываний.
После Imprecise прерывания продолжение выполнения не предполагается
(_The interrupted program is not restartable_).
Это `Abort`ы. И что-то ещё?
-->

## Маскировка прерываний

Внешние прерывания можно _замаскировать_ (англ. interrupt masking),
сбросив флаг _IF_ в регистре
флагов с помощью инструкции _CLI_ (**CL**ear **I** flag),
отложив их до момента,
когда маскировка будет отключена (_STI_, **S**e**T** **I** flag).
_Контроллер прерываний позволяет выборочно замаскировать запросы от
периферийных устройств._

**Немаскируемые** внешние прерывания
(_Non-Maskable interrupts, NMI_) маскируются только на время
обработки другого немаскируемого прерывания (до инструкции `IRET`).
Если `IRET` вызвала прерывание, то маскировка продлится до `IRET` в
обработчике нового прерывания.
Немаскируемые прерывания соответствуют вектору 2.
_Это название является, именем собственным для данных внешних прерываний._
_Например, программные прерывания вызванные инструкцией `INTn`
замаскировать нельзя, но их не называют немаскируемыми._

<!--
А что будет в случае цепочки таких прерываний?
Напрашивается эксперимент.
-->

Исключения маскируются процессором в случае одновременного возникновения,
исходя из их приоритета.
Флаг _IF_ на них не влияет.
Замаскированные прерывания не откладываются, а _отбрасываются_.
Но, если (_скорее всего_) причина отброшенного менее приоритетного исключения
не была устранена обработчиком более приоритетного исключения,
оно возникнет повторно.
_Некоторые исключения можно отключить с помощью битов в `CR0` и `CR4`. и др._

Внешние прерывания (запросы) имеют приоритет равный старшим
4-м битам вектора _(зависит от реализации)_.
Численно меньшие значения соответствуют меньшему приоритету.
Менее приоритетные запросы _откладываются_.
Младшие 4 бита регистра `CR8` (task-priority register, TPR) задают наивысший
приоритет маскируемых запросов, позволяя прерывать "задачу" только более
приоритетным запросам.

## Особенности

При переключении стека, после выполнения `POP SS` или `MOV SS` процессор не
совершит прерывание по внешней причине или по причине отладочной остановки,
давая возможность следующей инструкции изменить `ESP`
_(т.к. стек определяется сразу двумя регистрами: `SS:ESP`)_.
Для переключения стека _рекомендуется_ использовать инструкцию _LSS_.

_[Более подробные сведения][AMDManuals] см. в главе 8
документа "AMD64 Architecture Programmer’s Manual Volume 2: System
Programming"._

[AMDManuals]: https://developer.amd.com/resources/developer-guides-manuals/

## Прерывания в real mode

В real mode, элемент IDT содержит два слова (по 2 байта):
смещение обработчика (IP) и, следом, сегмент обработчика (CS).
В этом режиме IDT также называют IVT (interrupt vector table).

Прерывание выполняется в следующем порядке...

1. Младшие 16 бит регистра флагов кладутся на стек.
2. Сбрасываются флаги _IF_ (авто. маскировка внешних прерываний) и _TF_.
3. Регистр `CS` кладётся на стек.
4. Младшие 16 бит регистра `RIP` (регистр `IP`) кладётся на стек.
5. Регистры `CS` и `IP` загружаются из IDT.

Для завершения обработки прерывания используется инструкция `IRET`,
которая восстанавливает из стека `IP`, `CS` и флаги.

## Пример

В представленном примере производится перехват обработки прерываний в
real mode.
Перехватчик увеличивает счётчик соответственного прерывания, после чего
передаёт управление основному обработчику, назначенному BIOS.

Перехват обработки прерываний осуществляется путём перезаписи первых
элементов IDT, предварительно скопированных в отдельный массив.
Хотя адрес (0) и размер (0x400) IDT real mode являются стандартом,
при установке перехватчиков используется значение регистра `IDTR`, полученное
с помощью инструкции `SIDT` (_**S**tore **I**nterrupt **D**escriptor **T**able
Register_).

Значение регистра `IDTR` состоит из:

  - _лимита_ (_limit_, 2 байта), численно равного _смещению_ последнего
  байта (т.е. на единицу меньше размера),
  - _адреса_ (_base address_, **4** байта) элемента,
  соответствующего 0-ому вектору.

Главная программа выводит именованный список первых векторов вместе со
счётчиками и адресами основных обработчиков.
После каждого обновления программа приостанавливает процессор до следующего
прерывания с помощью инструкции `HLT`.

При запуске в эмуляторе Qemu наблюдается самостоятельной рост счётчика
прерываний от системного таймера (System Timer, вектор 8).
При нажатии и при отпускании клавиши на клавиатуре увеличивается счётчик
прерываний вектора 9.
